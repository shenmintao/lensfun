#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""This program reads Adobe LCP files and converts their content to one Lensfun
XML file.  It was tested against the LCP files shipped with “Adobe DNG
Converter 9.0” although it should work with other sets of LCP files, too.

This program assumes that one LCP file contains the data of exactly one lens.

It writes a single XML output file, by default into the personal DB directory.
While this directory has highest priority, note that other files in this
directory – albeit highly unlikely – might contain entries that override data
in that XML file.
"""

import os, argparse, sys, re, copy, glob, multiprocessing
from xml.etree import ElementTree

# Top-level definitions for multiprocessing compatibility on Windows

def child_without_attributes(parent, name):
    """Return the first child element that doesn't have attributes.  This is used
    e.g. for the ``<model>`` tag in order to get the version without the
    ``lang`` attribute.
    """
    for child in parent.findall(name):
        if not list(child.attrib.keys()):
            return child

class LensfunCamera:
    """One camera entry in Lensfun's database.  It is used to derive cropfactors of
    LCP entries from them, and the mounts of compact cameras.
    """
    def __init__(self, maker, model):
        self.maker, self.model = maker, model
        self.mount = None
        self.cropfactor = None

class LensfunLens:
    """One ``<lens>`` entry in Lensfun's database.
    """
    model_name_token_regex = re.compile(r"[0-9][0-9.]*|\s+|[^\w\s]+|[^\W\d_]+")

    def __init__(self, element):
        self.element = element
        model = child_without_attributes(element, "model").text
        self.normalized_model = self.normalize_lens_model_name(model)
        self.cropfactor = float(element.find("cropfactor").text)
        first_mount = element.find("mount").text
        if first_mount[0].islower():
            self.fixed_lens_mount = first_mount
        else:
            self.fixed_lens_mount = None
        self.chdk = "chdk" in model.lower()

    @staticmethod
    def normalize_lens_model_name(name):
        return tuple(token for token in LensfunLens.model_name_token_regex.findall(name.lower())
                    if token != "f" and not token.isspace() and
                    (len(token) > 1 or token.isalnum() or token in "*+"))

    def matches(self, names, cropfactor, fixed_lens_mount):
        if self.fixed_lens_mount and fixed_lens_mount == self.fixed_lens_mount and not self.chdk:
            return (1000, 0)
        scores = []
        for name in names:
            normalized_model = list(self.normalized_model)
            try:
                for token in self.normalize_lens_model_name(name):
                    normalized_model.remove(token)
            except ValueError:
                continue
            unmatched_tokens = len(normalized_model)
            if unmatched_tokens < 4:
                scores.append(10 - unmatched_tokens)
                break
        else:
            return (-1000, 0)
        cropfactor_ratio = cropfactor / self.cropfactor
        if not 0.96 < cropfactor_ratio < 1.041:
            return (-1000, 0)
        else:
            scores.append(10 - 100 * abs(1 - cropfactor_ratio))
        return tuple(scores)

class FieldNotFoundError(Exception):
    pass

class NoLCPDataUsed(Exception):
    pass

class NoFieldDefault:
    pass

# Important LCP namespaces
camera_ns = "{http://ns.adobe.com/photoshop/1.0/camera-profile}"
rdf_ns = "{http://www.w3.org/1999/02/22-rdf-syntax-ns#}"
# This regex identifies garbage in the <Lens> tag in the LCP file.
unusable_lens_name_regex = re.compile(r"[-0-9.]+\s*mm(\s*f/?[-0-9.]+)?|Sigma Lens$", re.IGNORECASE)
# This regex is used for finding a focal length in a string.
focal_length_regex = re.compile(r"([0-9.]+)\s*mm\b", re.IGNORECASE)

# Global data for worker processes, populated by init_worker
g_lensfun_cameras = None
g_lensfun_lenses = None
g_args = None

def init_worker(lensfun_cameras_arg, lensfun_lenses_arg, args_arg):
    """Initializer for worker processes."""
    global g_lensfun_cameras, g_lensfun_lenses, g_args
    g_lensfun_cameras = lensfun_cameras_arg
    g_lensfun_lenses = lensfun_lenses_arg
    g_args = args_arg

class LCPLens:
    """An entry in the LCP database.  It is identical with a single LCP file."""
    compact_cameras = []

    def __init__(self, filepath):
        tree = ElementTree.parse(filepath)
        self.old_format = bool(
            tree.findall(".//{http://ns.adobe.com/photoshop/1.0/camera-profile}Make"))
        self.calibration_entries = [self.get_description_element_maybe(entry) for entry in tree.getroot()[0][0][0][0]]
        self.read_first_entry()
        self.fix_focal_lengths()
        self.xml_element = self.xml_element()

    def get_description_element_maybe(self, element):
        if self.old_format:
            return element
        description = element.find(rdf_ns + "Description")
        if description is None:
            return element
        else:
            return description

    def read_field(self, element, field_name, default=NoFieldDefault):
        try:
            if self.old_format:
                return element.find(camera_ns + field_name).text
            else:
                return element.attrib[camera_ns + field_name]
        except (KeyError, AttributeError):
            if default is not NoFieldDefault:
                return default
            raise FieldNotFoundError(field_name)

    @staticmethod
    def clean_lens_maker(model):
        model_lower = model.lower()
        if "pentax" in model_lower: return "Pentax"
        if model_lower.startswith("hero"): return "GoPro"
        if model_lower.startswith("iphone"): return "Apple"
        if model_lower.startswith("inspire"): return "DJI"
        if model_lower.startswith("schneider"): return "Schneider-Kreuznach"
        if model_lower.startswith("phase one"): return "Phase One"
        if model_lower.startswith("venus optics"): return "Venus Optics"
        if "mitakon" in model_lower: return "Mitakon"
        if "cgo2g" in model_lower: return "Yuneec"
        if model_lower.startswith("slr magic"): return "SLR Magic"
        if model_lower.startswith("dp") and "quattro" in model_lower: return "Sigma"
        if "voigtlander" in model_lower: return "Voigtländer"
        if "handevision" in model_lower: return "HandeVision"
        maker = model.split()[0].capitalize()
        return maker

    def read_first_entry(self):
        entry = self.calibration_entries[0]
        camera_make = self.read_field(entry, "Make")
        self.camera_model = self.read_field(entry, "Model", camera_make)
        camera = g_lensfun_cameras.get((camera_make.lower(), self.camera_model.lower()))

        self.raw = self.read_field(entry, "CameraRawProfile", "True").lower() == "true"

        # Use LensPrettyName for the 'en' model and for maker detection
        self.model_en = self.read_field(entry, "LensPrettyName").strip()
        try:
            self.profile_name = self.read_field(entry, "ProfileName").strip()
        except FieldNotFoundError:
            self.profile_name = None
        self.maker = self.clean_lens_maker(self.model_en)

        # Build a list of model names to match against the Lensfun database
        # and to write into the new lens entry if no match is found.
        self.models = []
        try:
            # Per user request, use stCamera:Lens as the primary model name
            primary_model = self.read_field(entry, "Lens").strip()
            self.models.append(primary_model)
        except FieldNotFoundError:
            # Fallback to LensPrettyName if Lens is not present
            self.models.append(self.model_en)

        # Per user request, add AlternateLensNames to the list of models
        alt_names_element = entry.find(camera_ns + "AlternateLensNames")
        if alt_names_element is not None:
            seq_element = alt_names_element.find(rdf_ns + "Seq")
            if seq_element is not None:
                for li_element in seq_element.findall(rdf_ns + "li"):
                    if li_element.text:
                        alt_name = li_element.text.strip()
                        if alt_name not in self.models:
                             self.models.append(alt_name)

        # Ensure model_en is also in the list for matching if it's different
        if self.model_en not in self.models:
            self.models.append(self.model_en)
            
        try:
            self.cropfactor = float(self.read_field(entry, "SensorFormatFactor"))
        except FieldNotFoundError:
            self.cropfactor = camera and camera.cropfactor or 1
            
        self.fixed_lens_mount = None
        if camera:
            if camera.mount[0].islower():
                self.fixed_lens_mount = camera.mount
        elif re.search(r"coolpix|finefix|powershot|sony dsc|cyber-?shot|apple|iphone|hero|inspire|cgo2gb|samsung ex1",
                    self.model_en, re.IGNORECASE):
            self.fixed_lens_mount = "compactCamera" + str(abs(hash(self.model_en)))
            camera_element = ElementTree.Element("camera")
            ElementTree.SubElement(camera_element, "maker").text = camera_make
            ElementTree.SubElement(camera_element, "model").text = self.camera_model
            ElementTree.SubElement(camera_element, "mount").text = self.fixed_lens_mount
            ElementTree.SubElement(camera_element, "cropfactor").text = str(self.cropfactor)
            self.compact_cameras.append(camera_element)
            
        # Match against existing Lensfun database
        self.lensfun_lens = None
        best_scores = (-1000, 0)
        for lens in g_lensfun_lenses:
            scores = lens.matches(self.models, self.cropfactor, self.fixed_lens_mount)
            if scores > best_scores:
                best_scores = scores
                self.lensfun_lens = lens
                
        if self.lensfun_lens:
            # If found, use the official Lensfun maker/model to avoid creating duplicates.
            self.maker = child_without_attributes(self.lensfun_lens.element, "maker").text
            self.model = child_without_attributes(self.lensfun_lens.element, "model").text
        else:
            # If no match is found, the primary model is the first one from our list.
            self.model = self.models[0]
        
    def fix_focal_lengths(self):
        clean_entries = []
        for entry in self.calibration_entries:
            try:
                self.read_field(entry, "FocalLength")
            except FieldNotFoundError:
                match = focal_length_regex.search(self.model)
                focal_length = None
                if match:
                    focal_length = match.group(1)
                else:
                    try:
                        match = focal_length_regex.search(self.read_field(entry, "Lens"))
                    except FieldNotFoundError:
                        if "inspire 1 fc350" in self.model.lower():
                            focal_length = 20.7
                    else:
                        if match:
                            focal_length = match.group(1)
                if focal_length:
                    if self.old_format:
                        ElementTree.SubElement(entry, camera_ns + "FocalLength").text = str(focal_length)
                        clean_entries.append(entry)
                    else:
                        entry.attrib[camera_ns + "FocalLength"] = str(focal_length)
                        clean_entries.append(entry)
                else:
                    print("Warning: No focal length could be determined for {} / {}.".format(self.maker, self.model))
                    raise NoLCPDataUsed
            else:
                clean_entries.append(entry)
        self.calibration_entries = clean_entries

    def best_entries(self, tca):
        current_distances, current_apertures, result = {}, {}, {}
        for entry in self.calibration_entries:
            perspective_entry = entry.find(camera_ns + "PerspectiveModel")
            if perspective_entry is None:
                perspective_entry = entry.find(camera_ns + "FisheyeModel")
                if perspective_entry is None:
                    continue
            if tca and self.get_description_element_maybe(perspective_entry).find(camera_ns + "ChromaticRedGreenModel") is None:
                continue
            focal_length = float(self.read_field(entry, "FocalLength"))
            current_distance = current_distances.setdefault(focal_length, -2)
            current_aperture = current_apertures.setdefault(focal_length, 1001)
            distance = float(self.read_field(entry, "FocusDistance", -1))
            if distance > current_distance:
                aperture = float(self.read_field(entry, "ApertureValue", 1000))
                if abs(aperture - 8) < abs(current_aperture - 8):
                    current_distances[focal_length] = distance
                    current_apertures[focal_length] = aperture
                    result[focal_length] = entry
        return result

    def generate_distortion_entries(self):
        best_entries = self.best_entries(tca=False)
        elements = []
        fisheye = None
        for focal_length in sorted(best_entries):
            entry = best_entries[focal_length].find(camera_ns + "PerspectiveModel")
            if entry is None:
                entry = best_entries[focal_length].find(camera_ns + "FisheyeModel")
                assert fisheye != False
                fisheye = True
            else:
                assert fisheye != True
                fisheye = False
            entry = self.get_description_element_maybe(entry)
            element = ElementTree.Element("distortion", {"focal": str(focal_length), "model": "acm"})
            for i in range(1, 6):
                k = self.read_field(entry, "RadialDistortParam{}".format(i), None)
                if k is not None:
                    element.attrib["k{}".format(i)] = k
            elements.append(element)
        return elements, fisheye

    def generate_tca_entries(self):
        best_entries = self.best_entries(tca=True)
        elements = []
        for focal_length in sorted(best_entries):
            entry = best_entries[focal_length].find(camera_ns + "PerspectiveModel")
            if entry is None:
                entry = best_entries[focal_length].find(camera_ns + "FisheyeModel")
            entry = self.get_description_element_maybe(entry)
            element = ElementTree.Element("tca", {"focal": str(focal_length), "model": "acm"})
            for type_ in ["alpha", "beta"]:
                chromatic_element = entry.find(camera_ns + ("ChromaticRedGreenModel" if type_ == "alpha" else "ChromaticBlueGreenModel"))
                scale_factor = self.read_field(chromatic_element, "ScaleFactor", None)
                if scale_factor is not None:
                    element.attrib[type_ + "0"] = scale_factor
                for i in range(1, 6):
                    parameter = self.read_field(chromatic_element, "RadialDistortParam{}".format(i), None)
                    if parameter is not None:
                        element.attrib[type_ + str(i)] = parameter
            elements.append(element)
        return elements

    def generate_vignetting_entries(self):
        match = re.search(r"f/?(?P<min>[0-9.]+)", self.model, re.IGNORECASE)
        aperture_min = float(match.group("min")) if match else 0
        elements = []
        def sort_key(entry):
            focal_length = float(self.read_field(entry, "FocalLength"))
            aperture = float(self.read_field(entry, "ApertureValue", "nan"))
            distance = float(self.read_field(entry, "FocusDistance", "nan"))
            return (focal_length, aperture, distance)
        for entry in sorted(self.calibration_entries, key=sort_key):
            focal_length = self.read_field(entry, "FocalLength")
            try:
                aperture = self.read_field(entry, "ApertureValue")
                distance = self.read_field(entry, "FocusDistance")
            except FieldNotFoundError:
                continue
            if aperture_min > float(aperture):
                continue
            entry = entry.find(camera_ns + "PerspectiveModel")
            if entry is not None:
                entry = self.get_description_element_maybe(entry)
            if entry is not None:
                entry = entry.find(camera_ns + "VignetteModel")
                if entry is not None:
                    entry = self.get_description_element_maybe(entry)
                    element = ElementTree.Element("vignetting", {"focal": focal_length, "model": "acm", "aperture": aperture, "distance": distance})
                    for i in range(1, 6):
                        alpha = self.read_field(entry, "VignetteModelParam{}".format(i), None)
                        if alpha is not None:
                            element.attrib["alpha{}".format(i)] = alpha
                    elements.append(element)
        return elements

    def guess_ilc_mounts(self):
        mounts = set()
        if self.maker == "Nikon":
            mounts.add("Nikon CX" if 2.6 < self.cropfactor < 2.8 else "Nikon F AF")
        elif self.maker == "Canon":
            mounts.add("Canon EF-M" if "ef-m" in self.model.lower() else "Canon EF")
        elif self.maker == "Sony":
            mounts.add("Sony E" if "E " in self.model else "Sony Alpha")
        elif self.maker == "Pentax":
            mounts.add("Mamiya 645" if "645" in self.model else "Pentax KAF")
        elif self.maker == "Sigma":
            # 优先检查最具体的 "DN" (无反) 系列
            if "DG DN" in self.model_en:
                # DG DN 系列是为全画幅无反相机设计的
                if "SONY" in self.camera_model:
                    mounts.add("Sony E")
                elif "L-Mount" in self.model_en: # L卡口的命名通常在镜头名中
                    mounts.add("Leica L")
                # 如果没有明确线索，则添加所有可能性
                else:
                    mounts.update({"Sony E", "Leica L"})

            elif "DC DN" in self.model_en:
                # DC DN 系列是为APS-C无反相机设计的，卡口种类最多
                if "SONY" in self.camera_model:
                    mounts.add("Sony E")
                elif "FUJIFILM" in self.camera_model:
                    mounts.add("Fujifilm X")
                elif "Canon" in self.camera_model and " M" in self.camera_model: # 例如 "EOS M6"
                    mounts.add("Canon EF-M")
                elif "NIKON Z" in self.camera_model: # 例如 "NIKON Z 50"
                    mounts.add("Nikon Z")
                elif "OLYMPUS" in self.camera_model or "PANASONIC" in self.camera_model:
                    mounts.add("Micro 4/3 System")
                elif "L-Mount" in self.model_en:
                    mounts.add("Leica L")
                # 如果没有明确线索，则添加所有可能性
                else:
                    mounts.update({"Sony E", "Fujifilm X", "Canon EF-M", "Nikon Z", "Micro 4/3 System", "Leica L"})

            # 然后检查范围更广的 "DG" 和 "DC" (主要用于单反)
            elif "DG" in self.model_en:
                # DG 系列是为全画幅单反设计的，通常会提供多种主流卡口
                # LCP文件通常只关联一个相机系统，但镜头本身是多卡口的
                mounts.update({"Sigma SA", "Canon EF", "Nikon F AF", "Sony Alpha", "Pentax KAF"})

            elif "DC" in self.model_en:
                # DC 系列是为APS-C单反设计的
                mounts.update({"Sigma SA", "Canon EF", "Nikon F AF", "Sony Alpha", "Pentax KAF"})
            
            # 如果以上规则都未匹配（例如非常老的镜头），提供一个通用的回退
            else:
                print("Warning: Could not determine Sigma lens series (DG/DC/DN). Falling back to common mounts for {}.".format(self.model_en))
                mounts.update({"Sigma SA", "Canon EF", "Nikon F AF"})
        elif self.maker == "Zeiss":
            mounts.add("Sony E" if "E " in self.model else "Nikon F AF")
            if "E " not in self.model:
                mounts.update({"Fujifilm X", "Canon EF", "Leica M"})
        elif self.maker == "Voigtländer":
            mounts.update({"DKL", "Leica M", "M42", "Micro 4/3 System", "Nikon F"})
        elif self.maker == "Leica":
            if "-S " in self.model or " S " in self.model: mounts.add("Leica S")
            elif "-R " in self.model or " R " in self.model: mounts.add("Leica R")
            else: mounts.add("Leica M")
        elif self.maker == "Mamiya": mounts.add("Mamiya 645")
        elif self.maker == "Tokina": mounts.update({"Nikon F AF", "Sony Alpha", "Pentax KAF", "Canon EF", "Canon FD", "Minolta M", "Olympus OM"})
        elif self.maker == "Tamron": mounts.update({"Nikon F AF", "Sony Alpha", "Pentax KAF", "Canon EF"})
        elif self.maker == "Samsung":
            if "NX" in self.model or "NX" in self.camera_model: mounts.add("Samsung NX")
        elif self.maker == "HandeVision":
            mounts.add("Sony E" if "E " in self.model else "Canon EF-M")
            if "E " not in self.model: mounts.update({"Micro 4/3 System", "Fujifilm X"})
        elif self.maker == "SLR Magic": mounts.update({"Leica M", "Sony E", "Micro 4/3 System", "Fujifilm X"})
        elif self.maker == "Hasselblad":
            mounts.add("Sony E" if "LF" in self.model else "Hasselblad H")
        elif self.maker == "Mitakon": mounts.update({"Sony E", "Micro 4/3 System", "Fujifilm X", "Canon EF", "Nikon F AI"})
        elif self.maker == "Venus Optics": mounts.update({"Nikon F AF", "Sony Alpha", "Pentax KAF", "Canon EF"})
        elif self.maker == "Schneider-Kreuznach":
            if "phase one" in self.camera_model.lower(): mounts.update({"Hasselblad H", "Mamiya 645"})
        elif self.maker == "Phase One": mounts.update({"Hasselblad H", "Mamiya 645"})
        elif self.maker == "Lomography": mounts.update({"Nikon F AF", "Canon EF"})
        if not mounts:
            print("Warning: Fall back to default mounts for {} / {}.".format(self.maker, self.model))
            mounts = {"Sigma SA", "Nikon F AF", "Sony Alpha", "Pentax KAF", "Canon EF", "Minolta AF", "Canon FD", "Olympus OM", "4/3 System","Sony E","Canon RF","Nikon Z","Fujifilm X","Leica L"}
        elements = []
        for mount in mounts:
            element = ElementTree.Element("mount")
            element.text = mount
            elements.append(element)
        return elements

    def xml_element(self):
        if self.lensfun_lens:
            lens = copy.deepcopy(self.lensfun_lens.element)
            calibration = lens.find("calibration")
            if calibration is None:
                calibration = ElementTree.SubElement(lens, "calibration")
            lcp_entries_used = False
            if calibration.find("distortion") is None or g_args.prefer_lcp:
                entries, fisheye = self.generate_distortion_entries()
                if entries:
                    type_ = lens.find("type")
                    if fisheye:
                        if type_ is not None: type_.text = "fisheye"
                        else: lens.insert(max(len(lens) - 1, 0), ElementTree.Element("type", text="fisheye"))
                    elif type_ is not None:
                        lens.remove(type_)
                    for entry in calibration.findall("distortion"): calibration.remove(entry)
                    calibration.extend(entries)
                    lcp_entries_used = True
            if calibration.find("tca") is None or g_args.prefer_lcp:
                entries = self.generate_tca_entries()
                if entries:
                    for entry in calibration.findall("tca"): calibration.remove(entry)
                    calibration.extend(entries)
                    lcp_entries_used = True
            if calibration.find("vignetting") is None or g_args.prefer_lcp:
                entries = self.generate_vignetting_entries()
                if entries:
                    for entry in calibration.findall("vignetting"): calibration.remove(entry)
                    calibration.extend(entries)
                    lcp_entries_used = True
            if not lcp_entries_used:
                raise NoLCPDataUsed
        else:
            lens = ElementTree.Element("lens")
            ElementTree.SubElement(lens, "maker").text = self.maker

            # Use a set to avoid writing duplicate model names
            written_models = set()
            
            # Write the primary model (from stCamera:Lens or fallback)
            primary_model = self.models[0]
            ElementTree.SubElement(lens, "model").text = primary_model
            written_models.add(primary_model)

            # Write LensPrettyName as lang="en" if it's different
            if self.model_en not in written_models:
                ElementTree.SubElement(lens, "model", {"lang": "en"}).text = self.model_en
                written_models.add(self.model_en)

            # Write all other alternate names
            for model_name in self.models:
                if model_name not in written_models:
                    ElementTree.SubElement(lens, "model").text = model_name
                    written_models.add(model_name)
            
            if self.fixed_lens_mount:
                ElementTree.SubElement(lens, "mount").text = self.fixed_lens_mount
            else:
                lens.extend(self.guess_ilc_mounts())

            ElementTree.SubElement(lens, "cropfactor").text = str(self.cropfactor)
            entries, fisheye = self.generate_distortion_entries()
            if fisheye:
                ElementTree.SubElement(lens, "type").text = "fisheye"
            calibration = ElementTree.SubElement(lens, "calibration")
            if entries: calibration.extend(entries)
            entries = self.generate_tca_entries()
            if entries: calibration.extend(entries)
            entries = self.generate_vignetting_entries()
            if entries: calibration.extend(entries)
        
        self.correction_coverage = 0
        if calibration.find("distortion") is not None: self.correction_coverage += 1
        if calibration.find("tca") is not None: self.correction_coverage += 1
        if calibration.find("vignetting") is not None: self.correction_coverage += 1
        if not self.correction_coverage:
            print("Warning: LCP file for {} / {} contained no correction data.".format(self.maker, self.model))
            raise NoLCPDataUsed
        return lens

    @property
    def normalized_cropfactor(self):
        if 1.5 <= self.cropfactor <= 1.57: return 1.5
        elif 1.58 <= self.cropfactor <= 1.63: return 1.6
        elif 1.2 <= self.cropfactor <= 1.3: return 1.3
        else: return round(self.cropfactor * 10) / 10

def read_lcp_file(filepath):
    """Worker function to read and parse a single LCP file."""
    try:
        return LCPLens(filepath)
    except (ElementTree.ParseError, NoLCPDataUsed, IndexError, ValueError) as e:
        # IndexError can happen with malformed LCP files, e.g. tree.getroot()[0][0][0][0]
        # ValueError can happen on float conversions
        print(f"Skipping {filepath} due to parsing error: {type(e).__name__}: {e}")
        return None

def main():
    parser = argparse.ArgumentParser(description="Convert LCP files to a Lensfun XML file.")
    parser.add_argument("input_directory", default=".", nargs="?", metavar="path",
                        help="""path to the LCP files (default: ".")""")
    parser.add_argument("--output", default=os.path.expanduser("~/.local/share/lensfun/_lcps.xml"),
                        help="Path of output file (default: ~/.local/share/lensfun/_lcps.xml). This file is overwritten silently.")
    parser.add_argument("--db-path", help="Path to the lensfun database. If not given, look in the same places as Lensfun.")
    parser.add_argument("--prefer-lcp", action="store_true", help="Prefer LCP data over Lensfun data.")
    local_args = parser.parse_args()

    def indent(elem, level=0):
        i = "\n" + level * "    "
        if len(elem):
            if not elem.text or not elem.text.strip():
                elem.text = i + "    "
            for elem in elem:
                indent(elem, level + 1)
                if level == 0:
                    elem.tail = "\n" + i + "    "
            if not elem.tail or not elem.tail.strip():
                elem.tail = i
        else:
            if level and (not elem.tail or not elem.tail.strip()):
                elem.tail = i

    def read_lensfun_database():
        lensfun_cameras = {}
        lensfun_lenses_dict = {}
        def crawl_directory(dirpath):
            if not os.path.isdir(dirpath): return
            for filepath in glob.glob(os.path.join(dirpath, "*.xml")):
                if not os.path.basename(filepath).startswith("_"):
                    try:
                        tree = ElementTree.parse(filepath).getroot()
                        for element in tree.findall("camera"):
                            maker_elem = child_without_attributes(element, "maker")
                            model_elem = child_without_attributes(element, "model")
                            if maker_elem is not None and model_elem is not None:
                                maker, model = maker_elem.text, model_elem.text
                                lensfun_cameras[maker.lower(), model.lower()] = camera = LensfunCamera(maker, model)
                                camera.cropfactor = float(element.find("cropfactor").text)
                                camera.mount = element.find("mount").text
                        for element in tree.findall("lens"):
                            lens = LensfunLens(element)
                            lensfun_lenses_dict[lens.normalized_model, lens.cropfactor] = lens
                    except ElementTree.ParseError:
                        print(f"Warning: Could not parse Lensfun DB file: {filepath}")

        paths_search_list = [local_args.db_path] if local_args.db_path else \
                            ["/usr/share/lensfun", "/usr/local/share/lensfun", "/var/lib/lensfun-updates",
                            os.path.expanduser("~/.local/share/lensfun/updates"),
                            os.path.expanduser("~/.local/share/lensfun")]
        for path in paths_search_list:
            crawl_directory(path)
        return lensfun_cameras, set(lensfun_lenses_dict.values())

    local_lensfun_cameras, local_lensfun_lenses = read_lensfun_database()
    if not local_lensfun_cameras and not local_lensfun_lenses:
        print("Warning: No Lensfun database found.")

    def read_lcp_files():
        pool = multiprocessing.Pool(initializer=init_worker, initargs=(local_lensfun_cameras, local_lensfun_lenses, local_args))
        filepaths = []
        for root, __, filenames in os.walk(local_args.input_directory):
            for filename in filenames:
                if filename.lower().endswith('.lcp'):
                    filepaths.append(os.path.join(root, filename))
        
        results = pool.map(read_lcp_file, filepaths)
        pool.close()
        pool.join()

        lcp_lenses_dict = {}
        for lcp_lens in results:
            if lcp_lens:
                key = (lcp_lens.maker, lcp_lens.model, lcp_lens.normalized_cropfactor)
                already_existing_lens = lcp_lenses_dict.get(key)
                if not already_existing_lens or \
                   already_existing_lens.correction_coverage < lcp_lens.correction_coverage or \
                   (already_existing_lens.correction_coverage == lcp_lens.correction_coverage and already_existing_lens.cropfactor > lcp_lens.cropfactor):
                    lcp_lenses_dict[key] = lcp_lens
        return set(lcp_lenses_dict.values())

    lcp_lenses = read_lcp_files()

    output = ElementTree.Element("lensdatabase", {"version": "2"})
    for camera in LCPLens.compact_cameras:
        output.append(camera)
    for lens in lcp_lenses:
        output.append(lens.xml_element)
    indent(output)
    if len(output):
        output.text = "\n\n    "
        output.tail = "\n"
        output[-1].tail = "\n\n"
    
    output_dir = os.path.dirname(local_args.output)
    if output_dir:
        os.makedirs(output_dir, exist_ok=True)
        
    with open(local_args.output, "w", encoding="utf-8") as f:
        f.write(ElementTree.tostring(output, encoding="unicode"))

if __name__ == '__main__':
    multiprocessing.freeze_support()
    main()